/**
 *  Internal Host Service API
 */


syntax = "proto3";

package peloton.private.hostmgr.hostsvc;

option go_package = "peloton/private/hostmgr/hostsvc";

import "mesos/v1/mesos.proto";
import "peloton/api/peloton.proto";
import "peloton/api/task/task.proto";


/**
 *  HostOffer describes the resources available on a host by aggregating
 *  a list of Mesos offers to avoid offer defragmentation issue.
 */
message HostOffer {
  string hostname = 1;
  mesos.v1.AgentID agentId = 2;
  repeated mesos.v1.Resource resources = 3;
  repeated mesos.v1.Attribute attributes = 4;
}


/**
 *  LaunchableTask describes the task to be launched by host manager including Mesos
 *  task id and task config.
 */
message LaunchableTask {
  mesos.v1.TaskID taskId = 1;
  api.task.TaskConfig config = 2;

  // Dynamic ports reserved on the host while this instance is running. The key
  // is port name, value is port number.
  map<string, uint32> ports = 3;

  // Persistent volume used to launch task.
  Volume volume = 4;
}

/** QuantityControl includes input from placement engine to control how many
 * host offers need to be returned.
 */
message QuantityControl {
  // Optinoal maximum number of hosts to return. Default zero value is no-op.
  uint32 maxHosts = 1;

  // TODO(zhitao): Enable the following two fields.
  // Optional minimum number of hosts to return. This can be used to make sure
  // tasks can be well spread.
  // Default zero value is no-op.
  // Note that there is not guarantee hostmgr can return so many hosts, but
  // caller can use HostFilterResult included in response to understand.
  // uint32 minHosts = 2;

  // Original number of placements requested by PE. This cannot
  // be zero, otherwise hostmgr may return empty result.
  // uint32 numPlacements = 3;
}


/**
 * HostFilter can be used to control whether offers from a given host should
 * be returned to placement engine to use.
 */
message HostFilter {
  // Resource constraint which must be satisfied.
  ResourceConstraint resourceConstraint = 2;

  // Attribute based affinity/anti-affinity scheduling constraints, which is
  // typically copied from original task scheduling constraint.
  // Only constraint with kind == HOST will be considered.
  api.task.Constraint schedulingConstraint = 3;

  // Extra quantity control message which can be used to influence how many
  // host offers are returned.
  QuantityControl quantity = 4;
}

/**
 * HostFilterResult describes result of filtering hosts.
 */
enum HostFilterResult {
    // Reserved in case new result is unrecognized.
    UNKNOWN = 0;

    // Host is matched by filter and returned in HostOffer.
    MATCH = 1;

    // Host has enough total resources but offered resources
    // is insufficient (signal for fragmentation).
    INSUFFICIENT_OFFER_RESOURCES = 2;

    // Host is filtered out because of mismatched task -> host constraint.
    MISMATCH_CONSTRAINTS = 3;

    // Host has GPU so reserved for GPU only task.
    MISMATCH_GPU = 4;

    // Host is in mismatch status (i.e, another placement engine)
    // has a hold of the host.
    MISMATCH_STATUS = 5;

    // Host is filtered out because maxHosts limit is reached.
    MISMATCH_MAX_HOST_LIMIT = 6;

    // Host has no available offer to be matched. Usually this means the host is
    // fully used already.
    NO_OFFER = 7;

    // Host is filtered out because numPlacements * resourceConstraint
    // can already to satisfied.
    // MISMATCH_SUFFICIENT_TASKS ;

    // Host has not enough total resources.
    // INSUFFICIENT_TOTAL_RESOURCES ;
}

/**
 * ResourceConstraint descrbes a condition for which aggregated resources from
 * a host must meet in order for it to be returned in `AcquireHostOffers`.
 */
message ResourceConstraint {
  // Minimum amount of resources
  // NOTE: gpu resources are specially protected in the following way:
  //   - if `gpuLimit` is specified, only hosts with enough gpu resources are returned;
  //   - if `gpuLimit` is not specified, only hosts without gpu resource will be returned.
  api.task.ResourceConfig minimum = 1;

  // Number of dynamic ports
  uint32 numPorts = 2;

  // TODO(zhitao): Consider adding Maximum amount of resources constraint to
  // avoid fragmentation.
}

/**
 * Error for invalid argument.
 */
message InvalidArgument {
  string message = 1;

  // Any LaunchableTask whose content is invalid.
  repeated LaunchableTask invalidTasks = 2;
}

/**
 * Error for invalid task ids.
 */
message InvalidTaskIDs {
  string message = 1;

  // Any LaunchableTask whose content is invalid.
  repeated mesos.v1.TaskID taskIds = 2;
}

/**
 * Error for invalid offers.
 */
message InvalidOffers {
  string message = 1;
}

/**
 * Error when actually tasks launch failed.
 */
message LaunchFailure {
  string message = 1;
}

/**
 * Error when actually tasks kill failed.
 */
message KillFailure {
  string message = 1;
  repeated mesos.v1.TaskID taskIds = 2;
}

/**
 * Error for invalid filter.
 */
message InvalidHostFilter {
  string message = 1;

  // Invalid filter from input.
  HostFilter invalid = 2;
}

/**
 * Error when AcquireHostOffers failed.
 */
message AcquireHostOffersFailure {
  string message = 1;
}

/**
* Error when cluster is Unavailable
*/
message ClusterUnavailable {
  string message = 1;
}

/**
 *  Internal host service interface to be used by JobManager and
 *  PlacementEngine for task, reservation, volume and offer operations
 *
 *  TODO: figure out a better name for InternalHostService
 */
service InternalHostService
{
  /**
   *  Acquire a set of host offers from the host manager. Each host offer will
   *  only be used by one client at a given time.
   */
  rpc AcquireHostOffers(AcquireHostOffersRequest) returns (AcquireHostOffersResponse);

  /**
   *  Release unused host offers to the host manager.
   */
  rpc ReleaseHostOffers(ReleaseHostOffersRequest) returns (ReleaseHostOffersResponse);

  // Launch tasks on Mesos cluster
  rpc LaunchTasks(LaunchTasksRequest) returns (LaunchTasksResponse);

  // Kill tasks that are running on Mesos cluster
  rpc KillTasks(KillTasksRequest) returns (KillTasksResponse);

  // Reserve resources on a host
  rpc ReserveResources(ReserveResourcesRequest) returns (ReserveResourcesResponse);

  // Unreserve resources on a host
  rpc UnreserveResources(UnreserveResourcesRequest) returns (
      UnreserveResourcesResponse);

  // Create volumes on a Mesos host
  rpc CreateVolumes(CreateVolumesRequest) returns (CreateVolumesResponse);

  // Destroy volumes on a Mesos host
  rpc DestroyVolumes(DestroyVolumesRequest) returns (DestroyVolumesResponse);

  // TODO move out to separate service if scope widens
  // ClusterCapacity fetches the allocated resources to the framework`
  rpc ClusterCapacity(ClusterCapacityRequest) returns (ClusterCapacityResponse);

  // Performs batch offer operations.
  rpc OfferOperations(OfferOperationsRequest) returns (OfferOperationsResponse);
}

/**
 * Error for offer operations call to mesos failed.
 */
message OperationsFailure {
  string message = 1;
}

/**
 * Volume config used for offer create/launch operation.
 */
message Volume {
    // ID of the persistent volume.
    api.peloton.VolumeID id = 1;

    // the relative volume path inside the container.
    string containerPath = 2;

    // Resource needed for the volume.
    mesos.v1.Resource resource = 3;
}

message OfferOperation {
    // Defines an operation that can be performed against offers.
    enum Type {
      UNKNOWN = 0;
      LAUNCH = 1;
      RESERVE = 2;
      UNRESERVE = 3;
      CREATE = 4;
      DESTROY = 5;
    }

    message Reserve {
      // Mesos resources to be reserved.
      repeated mesos.v1.Resource resources = 1;
    }

    message Create {
      // Persistent volume to be created.
      Volume volume = 1;
    }

    message Launch {
      // List of tasks to be launched.
      repeated LaunchableTask tasks = 1;
    }

    message Destroy {
      // Persistent volume ID to be destroyed.
      string volumeID = 1;
    }

    message Unreserve {
      // The reservation label string to be unreserved.
      string label = 1;
    }

    // Type of the operation.
    Type type = 1;

    // Reservation labels used for operations.
    mesos.v1.Labels reservationLabels = 2;

    Reserve reserve = 3;
    Create create = 4;
    Launch launch = 5;
    Destroy destroy = 6;
    Unreserve unreserve = 7;
}

message OfferOperationsRequest {
    // Repeated Operations will be performed in sequential manner.
    repeated OfferOperation operations = 1;

    string hostname = 2;
}

message OfferOperationsResponse {
    message Error {
      OperationsFailure failure = 1;
      InvalidArgument invalidArgument = 2;
      InvalidOffers invalidOffers = 3;
    }

    Error error = 1;
}

message AcquireHostOffersRequest {
  HostFilter filter = 1;
}

message AcquireHostOffersResponse {
  message Error {
    InvalidHostFilter invalidHostFilter = 1;
    AcquireHostOffersFailure failure = 2;
  }

  Error error = 1;
  // The list of host offers that have been returned
  repeated HostOffer hostOffers = 2;

  // key: HostFilterResult's string form, value: count. used for debugging purpose.
  map<string, uint32> filterResultCounts = 3;
}

message ReleaseHostOffersRequest {
  repeated HostOffer hostOffers = 1;
}

message ReleaseHostOffersResponse {
  message Error {
  }

  Error error = 1;
}

message LaunchTasksRequest {
  string hostname = 1;
  repeated LaunchableTask tasks = 2;
  mesos.v1.AgentID agentId = 3;
}

message LaunchTasksResponse {
  message Error {
    InvalidArgument invalidArgument = 1;
    LaunchFailure launchFailure = 2;
    InvalidOffers invalidOffers = 3;
  }

  Error error = 1;
}

message KillTasksRequest {
  repeated mesos.v1.TaskID taskIds = 1;
}

message KillTasksResponse {
  message Error {
    InvalidTaskIDs invalidTaskIDs = 1;
    KillFailure killFailure = 2;
  }

  Error error = 1;
}

message ReserveResourcesRequest {
  repeated mesos.v1.Resource resources = 1;
}

message ReserveResourcesResponse {
  // TODO: Add errors that could fail a reserve resources request
}

message UnreserveResourcesRequest {
  repeated mesos.v1.Resource resources = 1;
}

message UnreserveResourcesResponse {
  // TODO: Add errors that could fail a unreserve resources request
}

message CreateVolumesRequest {
  repeated mesos.v1.Resource volumes = 1;
}

message CreateVolumesResponse {
  // TODO: Add errors that could fail a create volumes request
}

message DestroyVolumesRequest {
  repeated mesos.v1.Resource volumes = 1;
}

message DestroyVolumesResponse {
  // TODO: Add errors that could fail a destroy volumes request
}

/**
 *  Resource allocation for a resource
 */
message Resource {
  // Type of the resource
  string kind = 1;

  // capacity of the resource
  double capacity = 2;
}

message ClusterCapacityRequest {}

message ClusterCapacityResponse {
  message Error {
    ClusterUnavailable clusterUnavailable = 1;
  }

  Error error = 1;

  // Resources allocated
  repeated Resource resources = 2;

  // Resources for total physical capacity.
  repeated Resource physicalResources = 3;
}
