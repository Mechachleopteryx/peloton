/**
 *  Internal Host Service API
 */


syntax = "proto3";

package peloton.private.hostmgr.hostsvc;

option go_package = "peloton/private/hostmgr/hostsvc";

import "mesos/v1/mesos.proto";
import "peloton/api/task/task.proto";


/**
 *  HostOffer describes the resources available on a host by aggregating
 *  a list of Mesos offers to avoid offer defragmentation issue.
 */
message HostOffer {
  string hostname = 1;
  mesos.v1.AgentID agentId = 2;
  repeated mesos.v1.Resource resources = 3;
  repeated mesos.v1.Attribute attributes = 4;
}


/**
 *  LaunchableTask describes the task to be launched by host manager including Mesos
 *  task id and task config.
 */
message LaunchableTask {
  mesos.v1.TaskID taskId = 1;
  api.task.TaskConfig config = 2;
}


/**
 * Constraint describes a condition for which offers from a certain host must
 * meet in order to return to placement engine to use.
 */
message Constraint {
  // Maximum number of hosts which need to satisfy the given constraint.
  // Default value of zero means no repeat and this applies to one host.
  // TODO(zhitao): Consider adding `minimumHosts` which can be useful for
  // gang-scheduling.
  uint32 hostLimit = 1;

  ResourceConstraint resourceConstraint = 2;

  // Attribute based affinity/anti-affinity scheduling constraints, which is
  // typically copied from original task scheduling constraint.
  // Only constraint with kind == HOST will be considered.
  api.task.Constraint schedulingConstraint = 3;
}

/**
 * ResourceConstraint descrbes a condition for which aggregated resources from
 * a host must meet in order for it to be returned in `AcquireHostOffers`.
 */
message ResourceConstraint {
  // Minimum amount of resources
  // NOTE: gpu resources are specially protected in the following way:
  //   - if `gpuLimit` is specified, only hosts with enough gpu resources are returned;
  //   - if `gpuLimit` is not specified, only hosts without gpu resource will be returned.
  api.task.ResourceConfig minimum = 1;

  // TODO(zhitao): Consider adding Maximum amount of resources constraint to
  // avoid fragmentation.
}

/**
 * Error for invalid argument.
 */
message InvalidArgument {
  string message = 1;

  // Any LaunchableTask whose content is invalid.
  repeated LaunchableTask invalidTasks = 2;
}

/**
 * Error for invalid task ids.
 */
message InvalidTaskIDs {
  string message = 1;

  // Any LaunchableTask whose content is invalid.
  repeated mesos.v1.TaskID taskIds = 2;
}

/**
 * Error for invalid offers.
 */
message InvalidOffers {
  string message = 1;
}

/**
 * Error when actually tasks launch failed.
 */
message LaunchFailure {
  string message = 1;
}

/**
 * Error when actually tasks kill failed.
 */
message KillFailure {
  string message = 1;
  repeated mesos.v1.TaskID taskIds = 2;
}

/**
 * Error for invalid constraint.
 */
message InvalidConstraint {
  string message = 1;

  // Invalid constraint from input.
  Constraint invalid = 2;
}

/**
 * Error when AcquireHostOffers failed.
 */
message AcquireHostOffersFailure {
  string message = 1;
}

/**
* Error when cluster is Unavailable
*/
message ClusterUnavailable {
  string message = 1;
}

/**
 *  Internal host service interface to be used by JobManager and
 *  PlacementEngine for task, reservation, volume and offer operations
 *
 *  TODO: figure out a better name for InternalHostService
 */
service InternalHostService
{
  /**
   *  Acquire a set of host offers from the host manager. Each host offer will
   *  only be used by one client at a given time.
   */
  rpc AcquireHostOffers(AcquireHostOffersRequest) returns (AcquireHostOffersResponse);

  /**
   *  Release unused host offers to the host manager.
   */
  rpc ReleaseHostOffers(ReleaseHostOffersRequest) returns (ReleaseHostOffersResponse);

  // Launch tasks on Mesos cluster
  rpc LaunchTasks(LaunchTasksRequest) returns (LaunchTasksResponse);

  // Kill tasks that are running on Mesos cluster
  rpc KillTasks(KillTasksRequest) returns (KillTasksRequest);

  // Reserve resources on a host
  rpc ReserveResources(ReserveResourcesRequest) returns (ReserveResourcesResponse);

  // Unreserve resources on a host
  rpc UnreserveResources(UnreserveResourcesRequest) returns (
      UnreserveResourcesResponse);

  // Create volumes on a Mesos host
  rpc CreateVolumes(CreateVolumesRequest) returns (CreateVolumesResponse);

  // Destroy volumes on a Mesos host
  rpc DestroyVolumes(DestroyVolumesRequest) returns (DestroyVolumesResponse);

  // TODO move out to separate service if scope widens
  // ClusterCapacity fetches the allocated resources to the framework`
  rpc ClusterCapacity(ClusterCapacityRequest) returns (ClusterCapacityResponse);
}

message AcquireHostOffersRequest {
  // Required constraint.
  Constraint constraint = 1;
}

message AcquireHostOffersResponse {
  message Error {
    InvalidConstraint invalidConstraint = 1;
    AcquireHostOffersFailure failure = 2;
  }

  Error error = 1;
  // The list of host offers that have been returned
  repeated HostOffer hostOffers = 2;
}

message ReleaseHostOffersRequest {
  repeated HostOffer hostOffers = 1;
}

message ReleaseHostOffersResponse {
  message Error {
  }

  Error error = 1;
}

message LaunchTasksRequest {
  string hostname = 1;
  repeated LaunchableTask tasks = 2;
  mesos.v1.AgentID agentId = 3;
}

message LaunchTasksResponse {
  message Error {
    InvalidArgument invalidArgument = 1;
    LaunchFailure launchFailure = 2;
    InvalidOffers invalidOffers = 3;
  }

  Error error = 1;
}

message KillTasksRequest {
  repeated mesos.v1.TaskID taskIds = 1;
}

message KillTasksResponse {
  message Error {
    InvalidTaskIDs invalidTaskIDs = 1;
    KillFailure killFailure = 2;
  }

  Error error = 1;
}

message ReserveResourcesRequest {
  repeated mesos.v1.Resource resources = 1;
}

message ReserveResourcesResponse {
  // TODO: Add errors that could fail a reserve resources request
}

message UnreserveResourcesRequest {
  repeated mesos.v1.Resource resources = 1;
}

message UnreserveResourcesResponse {
  // TODO: Add errors that could fail a unreserve resources request
}

message CreateVolumesRequest {
  repeated mesos.v1.Resource volumes = 1;
}

message CreateVolumesResponse {
  // TODO: Add errors that could fail a create volumes request
}

message DestroyVolumesRequest {
  repeated mesos.v1.Resource volumes = 1;
}

message DestroyVolumesResponse {
  // TODO: Add errors that could fail a destroy volumes request
}

/**
 *  Resource allocation for a resource
 */
message Resource {
  // Type of the resource
  string kind = 1;

  // capacity of the resource
  double capacity = 2;
}

message ClusterCapacityRequest {}

message ClusterCapacityResponse {
  message Error {
    ClusterUnavailable clusterUnavailable = 1;
  }

  Error error = 1;

  // Resources allocated
  repeated Resource resources = 2;
}
