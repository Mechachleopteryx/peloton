/**
 *  Internal API for Peloton Resource Manager
 */

syntax = "proto3";

package peloton.private.resmgr;

option go_package = "peloton/private/resmgrsvc";

import "peloton/api/respool/respool.proto";
import "peloton/private/resmgr/resmgr.proto";
import "peloton/private/eventstream/eventstream.proto";


/**
 * ResourceManagerService describes the internal interface of
 * Resource Manager to other Peloton applications such as Job Manager
 * and Placement Engine. This includes the EnqueueGangs and GetPlacements
 * APIs called by Job Manager, and DequeueTasks and SetPlacements APIs
 * called by Placement Engine.
 */
service ResourceManagerService {

  /**
   *  Enqueue a list of Gangs, each of which is a list of
   *  one or more tasks, to a given leaf resource pool for
   *  scheduling. The Gangs will be in PENDING state first and then
   *  transit to READY state when the resource pool has available
   *  resources. This method will be called by Job Manager when a new
   *  job is created or new Gangs are added. If any Gangs
   *  fail to enqueue, Job Manager should retry those failed Gangs.
   */
  rpc EnqueueGangs(EnqueueGangsRequest) returns (EnqueueGangsResponse);

  /**
   *  Dequeue a list of tasks that are in READY state for placement.
   *  The tasks will transit from READY to PLACING state after the
   *  return of this method. This method will be called by Placement
   *  Engine to retrieve a list of tasks for computing placement. If
   *  tasks are in PLACING state for too long in case of Placement
   *  Engine failures, the tasks will be timed out and transit back
   *  to READY state.
   */
  rpc DequeueTasks(DequeueTasksRequest) returns (DequeueTasksResponse);

  /**
   *  Set the placement information for a list of tasks. The tasks will
   *  transit from PLACING to PLACED state after this call. This method
   *  will be called by Placement Engine after it computes the placement
   *  decision for those tasks.
   */
  rpc SetPlacements(SetPlacementsRequest) returns (SetPlacementsResponse);

  /**
   *  Get the placement information for a list of tasks. The tasks will
   *  transit from PLACED to LAUNCHING state after this call. This method
   *  is called by Job Manager to launch the tasks on Mesos. If the tasks
   *  are in LAUNCHING state for too long without transiting to RUNNING
   *  state, the tasks will be timedout and transit back to PLACED state.
   */
  rpc GetPlacements(GetPlacementsRequest) returns (GetPlacementsResponse);

  /**
   * Notifies task status updates to resource manager. This will be called by
   * Host manager to notify resource manager on task status updates.
   */
  rpc NotifyTaskUpdates(NotifyTaskUpdatesRequest) returns (NotifyTaskUpdatesResponse);

  /**
   * Get the list of Tasks running on the the list of host provided. This information
   * needed from the placement engines to find out what are the tasks running on
   * which hosts by that they can place tasks accordingly
   */
  rpc GetTasksByHosts(GetTasksByHostsRequest) returns (GetTasksByHostsResponse);
}

message ResourcePoolNotFound {
  api.respool.ResourcePoolID id = 1;
  string message = 2;
}

message ResourcePoolNoPermission {
  api.respool.ResourcePoolID id = 1;
  string message = 2;
}

message EnqueueGangsFailure {
  message FailedTask {
    resmgr.Task task = 1;
    string message = 2;
  }

  repeated FailedTask failed = 1;
}

message Gang {
  // List of tasks to be scheduled together
  repeated resmgr.Task tasks = 1;
}

message EnqueueGangsRequest {
  // ResourcePool
  api.respool.ResourcePoolID resPool = 1;

  // The list of gangs to enqueue
  repeated Gang gangs = 2;
}

message EnqueueGangsResponse {
  message Error {
    ResourcePoolNotFound notFound = 1;
    ResourcePoolNoPermission noPermission = 2;
    EnqueueGangsFailure failure = 3;
  }
  Error error = 1;
}

message RequestTimedout {
  string message = 1;
}

message DequeueTasksFailure {
  string message = 1;
}

message DequeueTasksRequest {
  // Max number of ready tasks to dequeue
  uint32 limit = 1;

  // Timeout in milliseconds if no tasks are ready
  uint32 timeout = 2;

  // Task Type to identify which kind of tasks need to be dequeued
  TaskType type = 3;
}

message DequeueTasksResponse {
  message Error {
    RequestTimedout timedout = 1;
    DequeueTasksFailure failure = 2;
  }
  Error error = 1;

  // The list of tasks that have been dequeued
  repeated resmgr.Task tasks = 2;
}

message SetPlacementsFailure {
  message FailedPlacement{
    resmgr.Placement placement = 1;
    string message = 2;
  }
  repeated FailedPlacement failed = 1;
}

message SetPlacementsRequest {
  // List of task placements to set
  repeated resmgr.Placement placements = 1;
}

message SetPlacementsResponse {
  message Error {
    SetPlacementsFailure failure = 1;
  }
  Error error = 1;
}

message GetPlacementsFailure {
  string message = 1;
}

message GetPlacementsRequest {
  // Max number of placements to retrieve
  uint32 limit = 1;

  // Timeout in milliseconds if no placements
  uint32 timeout = 2;
}

message GetPlacementsResponse {
  message Error {
    GetPlacementsFailure failure = 1;
  }
  Error error = 1;

  // List of task placements to return
  repeated resmgr.Placement placements = 2;
}

message NotifyTaskUpdatesError {
  string message = 1;
}

message NotifyTaskUpdatesRequest {
  repeated eventstream.Event events = 1;
}

message NotifyTaskUpdatesResponse {
  message Error {
    NotifyTaskUpdatesError error = 1;
  }
  Error error = 1;
  uint64 purgeOffset = 2;
}

// GetTasksByHostsRequest will always returns the currently running tasks
message GetTasksByHostsRequest {
  repeated string hostname = 1;

  // Task Type to identify which kind of tasks need to
  // be dequeued, if this is left out all tasks wil be returned.
  TaskType type = 2;
}

message TaskList {
  repeated resmgr.Task tasks = 1;
}

message GetTasksByHostsResponse {
  message Error {
    string message = 1;
  }
  Error error = 1;
  // This will return the list of tasks running on the host
  // If there is no tasks running on that host it will return
  // empty list
  map <string,TaskList> hostTasksMap = 2;
}
