/**
 *  Internal API for Peloton Resource Manager
 */

syntax = "proto3";

package peloton.private.resmgr;

option go_package = "peloton/private/resmgrsvc";

import "peloton/api/peloton.proto";
import "peloton/api/respool/respool.proto";
import "peloton/private/resmgr/resmgr.proto";
import "peloton/private/eventstream/eventstream.proto";


/**
 * ResourceManagerService describes the internal interface of
 * Resource Manager to other Peloton applications such as Job Manager
 * and Placement Engine. This includes the EnqueueGangs and GetPlacements
 * APIs called by Job Manager, and DequeueGangs and SetPlacements APIs
 * called by Placement Engine.
 */
service ResourceManagerService {

  /**
   *  Enqueue a list of Gangs, each of which is a list of
   *  one or more tasks, to a given leaf resource pool for
   *  scheduling. The Gangs will be in PENDING state first and then
   *  transit to READY state when the resource pool has available
   *  resources. This method will be called by Job Manager when a new
   *  job is created or new Gangs are added. If any Gangs
   *  fail to enqueue, Job Manager should retry those failed Gangs.
   */
  rpc EnqueueGangs(EnqueueGangsRequest) returns (EnqueueGangsResponse);

  /**
   *  Dequeue a list of Gangs, each comprised of tasks that are in READY
   *  state for placement.  The tasks will transit from READY to PLACING
   *  state after the return of this method. This method will be called by
   *  Placement Engine to retrieve a list of gangs for computing placement.
   *  If tasks are in PLACING state for too long in case of Placement
   *  Engine failures, the tasks will be timed out and transit back
   *  to READY state.
   */
  rpc DequeueGangs(DequeueGangsRequest) returns (DequeueGangsResponse);

  /**
   *  Set the placement information for a list of tasks. The tasks will
   *  transit from PLACING to PLACED state after this call. This method
   *  will be called by Placement Engine after it computes the placement
   *  decision for those tasks.
   */
  rpc SetPlacements(SetPlacementsRequest) returns (SetPlacementsResponse);

  /**
   *  Get the placement information for a list of tasks. The tasks will
   *  transit from PLACED to LAUNCHING state after this call. This method
   *  is called by Job Manager to launch the tasks on Mesos. If the tasks
   *  are in LAUNCHING state for too long without transiting to RUNNING
   *  state, the tasks will be timedout and transit back to PLACED state.
   */
  rpc GetPlacements(GetPlacementsRequest) returns (GetPlacementsResponse);

  /**
   * Notifies task status updates to resource manager. This will be called by
   * Host manager to notify resource manager on task status updates.
   */
  rpc NotifyTaskUpdates(NotifyTaskUpdatesRequest) returns (NotifyTaskUpdatesResponse);

  /**
   * Get the list of Tasks running on the the list of host provided. This
   * information is needed from the placement engines to find out which tasks
   * are running on which hosts so the placement engine can place tasks taking
   * this information into account.
   */
  rpc GetTasksByHosts(GetTasksByHostsRequest) returns (GetTasksByHostsResponse);

  /**
   * Get task to state map. This information is helpful for debug purpose.
   */
  rpc GetActiveTasks(GetActiveTasksRequest) returns (GetActiveTasksResponse);

  /**
   * Kill Tasks kills/Delete the tasks in Resource Manager
   */
  rpc KillTasks(KillTasksRequest) returns (KillTasksResponse);
}

message ResourcePoolNotFound {
  api.peloton.ResourcePoolID id = 1;
  string message = 2;
}

message ResourcePoolNoPermission {
  api.peloton.ResourcePoolID id = 1;
  string message = 2;
}

message EnqueueGangsFailure {
  message FailedTask {
    resmgr.Task task = 1;
    string message = 2;
  }

  repeated FailedTask failed = 1;
}

message Gang {
  // List of tasks to be scheduled together
  repeated resmgr.Task tasks = 1;
}

message EnqueueGangsRequest {
  // ResourcePool
  api.peloton.ResourcePoolID resPool = 1;

  // The list of gangs to enqueue
  repeated Gang gangs = 2;
}

message EnqueueGangsResponse {
  message Error {
    ResourcePoolNotFound notFound = 1;
    ResourcePoolNoPermission noPermission = 2;
    EnqueueGangsFailure failure = 3;
  }
  Error error = 1;
}

message RequestTimedout {
  string message = 1;
}

message DequeueGangsFailure {
  string message = 1;
}

message DequeueGangsRequest {
  // Max number of ready gangs to dequeue
  uint32 limit = 1;

  // Timeout in milliseconds if no gangs are ready
  uint32 timeout = 2;

  // Task Type to identify which kind of tasks need to be dequeued
  TaskType type = 3;
}

message DequeueGangsResponse {
  message Error {
    RequestTimedout timedout = 1;
    DequeueGangsFailure failure = 2;
  }
  Error error = 1;

  // The list of gangs that have been dequeued
  repeated Gang gangs = 2;
}

message SetPlacementsFailure {
  message FailedPlacement{
    resmgr.Placement placement = 1;
    string message = 2;
  }
  repeated FailedPlacement failed = 1;
}

message SetPlacementsRequest {
  // List of task placements to set
  repeated resmgr.Placement placements = 1;
}

message SetPlacementsResponse {
  message Error {
    SetPlacementsFailure failure = 1;
  }
  Error error = 1;
}

message GetPlacementsFailure {
  string message = 1;
}

message GetPlacementsRequest {
  // Max number of placements to retrieve
  uint32 limit = 1;

  // Timeout in milliseconds if no placements
  uint32 timeout = 2;
}

message GetPlacementsResponse {
  message Error {
    GetPlacementsFailure failure = 1;
  }
  Error error = 1;

  // List of task placements to return
  repeated resmgr.Placement placements = 2;
}

message NotifyTaskUpdatesError {
  string message = 1;
}

message NotifyTaskUpdatesRequest {
  repeated eventstream.Event events = 1;
}

message NotifyTaskUpdatesResponse {
  message Error {
    NotifyTaskUpdatesError error = 1;
  }
  Error error = 1;
  uint64 purgeOffset = 2;
}

// GetTasksByHostsRequest will always returns the currently running tasks
message GetTasksByHostsRequest {
  repeated string hostnames = 1;

  // Task Type to identify which kind of tasks need to
  // be dequeued, if this is left out all tasks wil be returned.
  TaskType type = 2;
}

message TaskList {
  repeated resmgr.Task tasks = 1;
}

message GetTasksByHostsResponse {
  message Error {
    string message = 1;
  }
  Error error = 1;
  // This will return a map from hostname to a list of tasks running on the host.
  map <string,TaskList> hostTasksMap = 2;
}

message GetActiveTasksRequest {
  // optional jobID to filter out tasks
  string jobID = 1;

  // optional respoolID to filter out tasks
  string respoolID = 2;
}

message GetActiveTasksResponse {
  message Error {
    string message = 1;
  }
  Error error = 1;
  // This will return a map from task id to state.
  map <string,string> taskStatesMap = 2;
}

message KillTasksRequest {
  // Peloton Task Ids for
  repeated api.peloton.TaskID tasks = 1;
}

message TasksNotFound {
  api.peloton.TaskID task = 1;
  string message = 2;
}

message KillTasksError {
  api.peloton.TaskID task = 1;
  string message = 2;
}

message KillTasksResponse {
  message Error {
   TasksNotFound notFound = 1;
   KillTasksError killError =2;
  }
  repeated Error error = 1;
}

