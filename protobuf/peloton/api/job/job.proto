/**
 *  Job Manager API
 */


syntax = "proto3";

package peloton.api.job;

option go_package = "peloton/api/job";

import "mesos/v1/mesos.proto";
import "peloton/api/peloton.proto";
import "peloton/api/errors/errors.proto";
import "peloton/api/task/task.proto";
import "peloton/api/respool/respool.proto";

/**
 *  Job type definition such as batch, service and infra agent.
 */
enum JobType {
  // Normal batch job which will run to completion after all instances finishes.
  BATCH = 0;

  // Service job which is long running and will be restarted upon failures.
  SERVICE = 1;

  // Daemon job which has one instance running on each host for infra
  // agents like muttley, m3collector etc.
  DAEMON = 2;
}


/**
 *  SLA configuration for a job
 */
message SlaConfig {

  //
  // Priority of a job. Higher value takes priority over lower value
  // when making scheduling decisions as well as preemption decisions
  //
  uint32 priority = 1;

  //
  // Whether the job instances are preemptible. If so, it might
  // be scheduled using revocable offers
  //
  bool preemptible = 2;

  //
  // Whether the job instances are revocable. If so, it might
  // be scheduled using revocable resources and subject to preemption
  // when other jobs reclaims those resources.
  //
  bool revocable = 3;

  //
  // Maximum number of instances to admit and run at any point in time.
  // If specified, should be <= instanceCount and >= minimumRunningInstances;
  // default value is instanceCount.
  //
  uint32 maximumRunningInstances = 4;

  //
  // Minimum number of instances to admit and run at any point in time.
  // If specified, should be <= maximumRunningInstances <= instanceCount;
  // default value is 1.  Admission requires the corresponding resource pool
  // has enough reserved resources for the full set of minimum number of instances.
  //
  uint32 minimumRunningInstances = 5;
}


/**
 *  Job configuration
 */
message JobConfig {

  // Change log entry of the job config
  peloton.ChangeLog changeLog = 1;

  // Name of the job
  string name = 2;

  // Type of the job
  JobType type = 3;

  // Owning team of the job
  string owningTeam = 4;

  // LDAP groups of the job
  repeated string ldapGroups = 5;

  // Description of the job
  string description = 6;

  // List of user-defined labels for the job
  mesos.v1.Labels labels = 7;

  // Number of instances of the job
  uint32 instanceCount = 8;

  // SLA config of the job
  SlaConfig sla = 9;

  // Default task configuration of the job
  task.TaskConfig defaultConfig = 10;

  // Instance specific task config which overwrites the default one
  map<uint32, task.TaskConfig> instanceConfig = 11;

  // Resource Pool ID where this job belongs to
  respool.ResourcePoolID respoolID = 12;
}


/**
 *  Runtime states of a Job
 */
enum JobState {
  // Reserved for future compatibility of new states.
  UNKNOWN = 0;

  // The job has been initialized and persisted in DB.
  INITIALIZED = 1;

  // All tasks in the job are created and enqueued to resource manager
  PENDING = 2;

  // Any of the tasks in the job is in RUNNING state.
  RUNNING = 3;

  // All tasks in the job are in SUCCEEDED state.
  SUCCEEDED = 4;

  // All tasks in the job are in terminated state and one or more
  // tasks is in FAILED state.
  FAILED = 5;

  // All tasks in the job are in terminated state and one or more
  // tasks in the job is killed by the user.
  KILLED = 6;
}


/**
 *  Job RuntimeInfo provides the current runtime status of a Job
 */
message RuntimeInfo
{
  // State of the job
  JobState state = 1;

  // The time when the job was created. The time is represented in
  // RFC3339 form with UTC timezone.
  string creationTime = 2;

  // The time when the first task of the job starts to run. The time
  // is represented in RFC3339 form with UTC timezone.
  string startTime = 3;

  // The time when the last task of the job is completed. The time is
  // represented in RFC3339 form with UTC timezone.
  string completionTime = 4;

  // The number of tasks grouped by each task state. The map key is
  // the task.TaskState in string format and the map value is the number
  // of tasks in the particular state.
  map<string, uint32> taskStats = 5;
}


/**
 *  Job Manager service interface
 */
service JobManager {

  // Create a Job entity for a given config
  rpc Create(CreateRequest) returns (CreateResponse);

  // Get the config of a job entity
  rpc Get(GetRequest) returns (GetResponse);

  // Query the jobs that match a list of labels.
  rpc Query(QueryRequest) returns (QueryResponse);

  // Delete a job entity and stop all related tasks
  rpc Delete(DeleteRequest) returns (DeleteResponse);
}

message JobAlreadyExists {
  peloton.JobID id = 1;
  string message = 2;
}

message InvalidJobId {
  peloton.JobID id = 1;
  string message = 2;
}


message InvalidJobConfig {
  peloton.JobID id = 1;
  string message = 2;
}

message CreateRequest {
  peloton.JobID id = 1;
  JobConfig config = 2;
}

message CreateResponse {
  message Error {
    JobAlreadyExists alreadyExists = 1;
    InvalidJobConfig invalidConfig = 2;
    InvalidJobId     invalidJobId = 3;
  }

  Error error = 1;
  peloton.JobID jobId = 2;
}

message GetRequest {
  peloton.JobID id = 1;
}

message GetResponse {
  message Error {
    errors.JobNotFound notFound = 1;
    errors.JobGetRuntimeFail getRuntimeFail = 2;
  }

  Error error = 1;
  JobConfig config = 2;
  RuntimeInfo runtime = 3;
}

message QueryRequest {
  // Both labels/respoolID/keywords fields are optional,
  // and while query is executed, the fields are
  // in "AND" relationship if they are both specified.
  mesos.v1.Labels labels = 1;
  respool.ResourcePoolID respoolID = 2;
  repeated string keywords = 3;
}

message QueryResponse {
   message Error {
    errors.UnknownError err = 1;
    errors.InvalidRespool invalidRespool = 2;
  }

  map<string, JobConfig> result = 1;
  Error error = 2;
}

message DeleteRequest {
  peloton.JobID id = 1;
}

message DeleteResponse {
  message Error {
    errors.JobNotFound notFound = 1;
  }

  Error error = 1;
}
