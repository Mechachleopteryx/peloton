/**
 *  This file defines the Task related messages in Peloton API
 */

syntax = "proto3";

package peloton.api.task;

option go_package = "peloton/api/task";

import "mesos/v1/mesos.proto";
import "peloton/api/peloton.proto";
import "peloton/api/errors/errors.proto";

/**
 *  Resource configuration for a task.
 */
message ResourceConfig {

  // CPU limit in number of CPU cores
  double cpuLimit = 1;

  // Memory limit in MB
  double memLimitMb = 2;

  // Disk limit in MB
  double diskLimitMb = 3;

  // File descriptor limit
  uint32 fdLimit = 4;

  // GPU limit in number of GPUs
  double gpuLimit = 5;
}


/**
 *  Health check configuration for a task
 */
message HealthCheckConfig {

  // Whether the health check is enabled.
  bool enabled = 1;

  // Start time wait in seconds.
  // Zero or empty value would use default value of 15 from Mesos.
  uint32 initialIntervalSecs = 2;

  // Interval in seconds between two health checks.
  // Zero or empty value would use default value of 10 from Mesos.
  uint32 intervalSecs = 3;

  // Max number of consecutive failures before failing health check.
  // Zero or empty value would use default value of 3 from Mesos.
  uint32 maxConsecutiveFailures = 4;

  // Health check command timeout in seconds.
  // Zero or empty value would use default value of 20 from Mesos.
  uint32 timeoutSecs = 5;

  enum Type {
    // Reserved for future compatibility of new types.
    UNKNOWN = 0;

    // Command line based health check
    COMMAND = 1;

    // HTTP endpoint based health check
    HTTP = 2;
  }

  message CommandCheck {
    // Health check command to be executed.
    // Note that this command by default inherits all environment varibles from
    // the task it's monitoring, unless `unshare_environments` is set to true.
    string command = 1;

    // If set, this check will not share the environment variables of the task.
    bool unshareEnvironments = 2;
  }

  Type type = 6;

  // Only applicable when type is `COMMAND`.
  CommandCheck commandCheck = 7;
}


/**
 *  Network port configuration for a task
 */
message PortConfig {

  // Name of the network port, e.g. http, tchannel. Required field.
  string name = 1;

  // Static port number if any. If unset, will be dynamically allocated
  // by the scheduler
  uint32 value = 2;

  // Environment variable name to be exported when running a task for this port.
  // Required field for dynamic port.
  string envName = 3;
}

/**
 * Constraint represents a host label constraint or a related tasks label constraint.
 * This is used to require that a host have certain label constraints or to require
 * that the tasks already running on the host have certain label constraints.
 */
message Constraint {
  enum Type {
    // Reserved for compatibility.
    UNKNOWN_CONSTRAINT = 0;
    LABEL_CONSTRAINT   = 1;
    AND_CONSTRAINT     = 2;
    OR_CONSTRAINT      = 3;
  }

  Type type = 1;

  LabelConstraint labelConstraint = 2;
  AndConstraint   andConstraint   = 3;
  OrConstraint    orConstraint    = 4;
}

/**
 * AndConstraint represents a logical 'and' of constraints.
 */
message AndConstraint {
  repeated Constraint constraints  = 1;
}

/**
 * OrConstraint represents a logical 'or' of constraints.
 */
message OrConstraint {
  repeated Constraint constraints  = 1;
}

/**
 * LabelConstraint represents a constraint on the number of occources a given
 * label from the set of host labels or task labels present on the host.
 */
message LabelConstraint {
  /**
   * Condition represents a constraint on the number of occurrences of the label.
   */
  enum Condition {
    // Reserved for compatibility.
    CONDITION_UNKNOWN               = 0;
    CONDITION_LESS_THAN             = 1;
    CONDITION_EQUAL                 = 2;
    CONDITION_GREATER_THAN          = 3;
  }

  /**
   * Kind represents whatever the constraint applies to the labels on the host
   * or to the labels of the tasks that are located on the host.
   */
  enum Kind {
    // Reserved for compatibility.
    UNKNOWN = 0;
    TASK    = 1;
    HOST    = 2;
  }

  // Determines which labels the constraint should apply to.
  Kind           kind        = 1;
  // Determines which constraint there should be on the number of occurrences of the label.
  Condition      condition   = 2;
  // The label which this defines a constraint on:
  // For Kind == HOST, each attribute on Mesos agent is transformed to a label,
  // with `hostname` as a special label which is always inferred from agent
  // hostname and set.
  mesos.v1.Label label       = 3;
  // A limit on the number of occurrences of the label.
  uint32         requirement = 4;
}

/**
 *  Restart policy for a task.
 */
message RestartPolicy {

  // Max number of task failures can occur before giving up scheduling retry, no
  // backoff for now. Default 0 means no retry on failures.
  uint32 maxFailures = 1;
}

/**
 *  Persistent volume configuration for a task.
 */
message PersistentVolumeConfig {
    // Volume mount path inside container.
    string containerPath = 1;

    // Volume size in MB.
    uint32 sizeMB = 2;
}

/**
 *  Task configuration for a given job instance
 *  Note that only add string/slice/ptr type into TaskConfig directly due to
 *  the limitation of go reflection inside our task specific config logic.
 */
message TaskConfig {
  // Name of the task
  string name = 1;

  // List of user-defined labels for the task
  mesos.v1.Labels labels = 2;

  // Resource config of the task
  ResourceConfig resource = 3;

  // Container config of the task.
  mesos.v1.ContainerInfo container = 4;

  // Command line config of the task
  mesos.v1.CommandInfo command = 5;

  // Health check config of the task
  HealthCheckConfig healthCheck = 6;

  // List of network ports to be allocated for the task
  repeated PortConfig ports = 7;

  // Constraint on the attributes of the host or labels on tasks on the host
  // that this task should run on.
  // Use `AndConstraint`/`OrConstraint` to compose multiple constraints if
  // necessary.
  Constraint constraint = 8;

  // Task restart policy, unset means no restart.
  RestartPolicy restartPolicy = 9;

  // Persistent volume config of the task.
  PersistentVolumeConfig volume = 10;
}

/**
 *  Runtime states of a task instance
 */
enum TaskState {
  // Reserved for future compatibility of new states.
  UNKNOWN     = 0;

  // The task is being initialized
  INITIALIZED = 1;

  // The task is pending and waiting for resources
  PENDING     = 2;

  // The task has been allocated with resources and ready for placement
  READY       = 3;

  // The task is being placed to a host based on its resource
  // requirements and constraints
  PLACING     = 4;

  // The task has been assigned to a host matching the resource
  // requirements and constraints
  PLACED      = 5;

  // The task is being launched Mesos master
  LAUNCHING   = 6;

  // The task is being started by Mesos agent
  STARTING    = 7;

  // The task is running on a Mesos host
  RUNNING     = 8;

  // The task terminated with an exit code of zero
  SUCCEEDED   = 9;

  // The task terminated with a non-zero exit code
  FAILED      = 10;

  // The task is lost
  LOST        = 11;

  // The task is being preempted by another one on the node
  PREEMPTING  = 12;

  // The task is being killed
  KILLING     = 13;

  // Execution of the task was terminated by the system
  KILLED      = 14;
}

/**
 *  Runtime info of an task instance in a Job
 */
message RuntimeInfo {
  // Runtime status of the task
  TaskState state = 1;

  // The mesos task ID for this instance
  mesos.v1.TaskID taskId = 2;

  // The start time of the instance. The instance is stopped when unset
  mesos.v1.TimeInfo startedAt = 3;

  // The name of the host where the instance is running
  string host = 4;

  // Dynamic ports reserved on the host while this instance is running
  map<string, uint32> ports = 5;

  // Goalstate of the task
  TaskState goalState = 6;

  // The message about task updates
  string message = 7;

  // The reason for task updates
  string reason = 8;

  // number of task failures
  uint32 failuresCount = 9;
}


/**
 *  Info of a task instance in a Job
 */
message TaskInfo {
  // The numerical ID assigned to this instance. Instance IDs must be
  // unique and contiguous within a job. The ID is in the range of
  // [0, N-1] for a job with instance count of N.
  uint32 instanceId = 1;

  // Job ID of the task
  peloton.JobID jobId = 2;

  // Configuration of the task
  TaskConfig config = 3;

  // Runtime info of the instance
  RuntimeInfo runtime = 4;
}


/**
 *  Task manager interface
 */
service TaskManager
{
  // Get the info of a task in job.
  rpc Get(GetRequest) returns (GetResponse);

  // List all task info in a job.
  rpc List(ListRequest) returns (ListResponse);
  
  // Start a set of tasks for a job. Will be no-op for tasks that
  // are currently running.
  rpc Start(StartRequest) returns (StartResponse);

  // Stop a set of tasks for a job. Will be no-op for tasks that
  // are currently stopped.
  rpc Stop(StopRequest) returns (StopResponse);

  // Restart a set of tasks for a job. Will start tasks that are
  // currently stopped.
  rpc Restart(RestartRequest) returns (RestartResponse);

  // Query task info in a job, using a set of filters.
  rpc Query(QueryRequest) returns (QueryResponse);

  // BrowseSandbox returns list of file paths inside sandbox.
  rpc BrowseSandbox(BrowseSandboxRequest) returns (BrowseSandboxResponse);
}

/**
 *  Failures for browsing sandbox files requests to mesos call.
 */
message BrowseSandboxFailure {
  string message = 1;
}

/**
 *  Task not running error.
 */
message TaskNotRunning {
  string message = 1;
}

message BrowseSandboxRequest {
  peloton.JobID jobId = 1;
  uint32 instanceId = 2;
}

message BrowseSandboxResponse {
  message Error {
    errors.JobNotFound notFound = 1;
    InstanceIdOutOfRange outOfRange = 2;
    TaskNotRunning notRunning = 3;
    BrowseSandboxFailure failure = 4;
  }

  Error error = 1;
  string hostname = 2;
  string port = 3;
  repeated string paths = 4;
}

message InstanceIdOutOfRange
{
  // Entity ID of the job
  peloton.JobID jobId = 1;

  // Instance count of the job
  uint32 instanceCount = 2;
}

message GetRequest {
  peloton.JobID jobId = 1;
  uint32 instanceId = 2;
}

message GetResponse {
  TaskInfo result = 1;
  errors.JobNotFound notFound = 2;
  InstanceIdOutOfRange outOfRange = 3;
}

/**
 *  Task InstanceID range [from, to)
 */
message InstanceRange {
  uint32 from = 1;
  uint32 to = 2;
}

message ListRequest {
  peloton.JobID jobId = 1;
  InstanceRange range = 2;
}

message ListResponse {
  message Result {
    map<uint32, TaskInfo> value = 1;
  }
  Result result = 1;
  errors.JobNotFound notFound = 2;
}

message StartRequest {
  peloton.JobID jobId = 1;
  repeated InstanceRange ranges = 2;
}

message StartResponse {
  errors.JobNotFound notFound = 1;
  InstanceIdOutOfRange outOfRange = 2;
}

// If no ranges specified, then stop all the tasks in the job.
message StopRequest {
  peloton.JobID jobId = 1;
  repeated InstanceRange ranges = 2;
}

message TaskUpdateError {
  string message = 1;
}

message StopResponse {
  message Error {
    errors.JobNotFound notFound = 1;
    InstanceIdOutOfRange outOfRange = 2;
    TaskUpdateError updateError = 3;
  }

  Error error = 1;
  repeated uint32 stoppedInstanceIds = 2;
  repeated uint32 invalidInstanceIds = 3;
}

message RestartRequest {
  peloton.JobID jobId = 1;
  repeated InstanceRange ranges = 2;
}

message RestartResponse {
  errors.JobNotFound notFound = 1;
  InstanceIdOutOfRange outOfRange = 2;
}

message QueryRequest {
  peloton.JobID jobId = 1;
  uint32 offset = 2;
  uint32 limit = 3;

  message OrderBy {
    enum Order {
      UNKNOWN = 0;
      ASC = 1;
      DESC = 2;
    }

    Order order = 1;
    string field = 2;
  }

  repeated OrderBy orderBy = 4;

  message QueryFilter {
    // TODO: Should we call this property?
    string field = 1;

    enum Operator {
      EQUAL = 0;
      NOT_EQUAL = 1;
      CONTAINS = 2;
    }

    Operator operator = 2;

    string value = 3;
  }

  repeated QueryFilter queryFilters = 5;

}

message QueryResponse {
  repeated TaskInfo records = 1;
  uint32 offset = 2;
  uint32 limit = 3;
  uint32 total = 4;

  message Error {
    errors.JobNotFound notFound = 1;
  }

  Error error = 5;
}

message TaskEvent {

  // Describes the source of the task event
  enum Source {
    SOURCE_UNKNOWN = 0;
    SOURCE_JOBMGR = 1;
    SOURCE_RESMGR = 2;
    SOURCE_HOSTMGR = 3;
  }

  // TODO add reason
  // with detailed reason for the task event

  peloton.TaskID task_id = 1;
  TaskState state = 2;
  // Short human friendly message explaining state.
  string message = 3;
  // The time when the event was created. The time is represented in
  // RFC3339 form with UTC timezone.
  string timestamp = 4;
  Source source = 5;
}
